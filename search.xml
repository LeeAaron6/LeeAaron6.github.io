<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue 小程序表达式]]></title>
    <url>%2F2018%2F08%2F03%2FVue-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[最近写了很多动态添加类名或者tab标签切换的表达式，遇到过很多的坑，下面为大家分享一下我遇到的几种。未完待续]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>Mini-apps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端拖拽]]></title>
    <url>%2F2018%2F07%2F23%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8B%96%E6%8B%BD%2F</url>
    <content type="text"><![CDATA[最近在做一个混合开发的项目，需求里面要求使用拖拽，然而这不是jq的拖拽；我向很多大佬求助过，有一位大佬建议我去使用hammer.js;由于时间紧迫我不得不放弃这一方法。还有大佬向我推荐vue封装的插件，然而我试了一下有局限性，position:absolute==&gt;我想要是的fixed；还有通过指令的方法等等我都试了不好用；求人不如求己下面我将为大家介绍一种简单的方法（适用于vue） 完整代码展示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126 &lt;template&gt; &lt;div class="detail"&gt; &lt;!-- 头部 --&gt; &lt;app-header&gt;&lt;/app-header&gt; &lt;!-- 报障人信息 --&gt; &lt;app-person&gt;&lt;/app-person&gt; &lt;!-- 报障内容 --&gt; &lt;app-content&gt;&lt;/app-content&gt; &lt;!-- 处理进度 --&gt; &lt;app-progress&gt;&lt;/app-progress&gt; &lt;!-- 底部导航栏 --&gt; &lt;app-nav&gt;&lt;/app-nav&gt; &lt;!-- 遮罩层 --&gt; &lt;div class="home" id="moveDiv" @click="gohome" @touchstart="down" @touchmove="move" @touchend="end"&gt; &lt;img src="../../../../Img/img/home.png" alt=""&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import AppHeader from "./vue/header.vue";import AppPerson from "./vue/person.vue";import AppContent from "./vue/content.vue";import AppProgress from "./vue/progress.vue";import AppNav from "./vue/nav.vue";// import AppMask from './vue/mask.vue';export default &#123; data() &#123; return &#123; flags: false, position: &#123; x: 0, y: 0 &#125;, nx: '', ny: '', dx: '', dy: '', xPum: '', yPum: '', &#125;; &#125;, methods: &#123; gohome:function()&#123; //跳转home this.$router.push(&#123; name:'index', // query:&#123;engineerNum:this.engineerNum&#125; &#125;) &#125;, down()&#123; console.log('down'); this.flags = true; var touch ; if(event.touches)&#123; touch = event.touches[0]; &#125;else &#123; touch = event; &#125; this.position.x = touch.clientX; this.position.y = touch.clientY; this.dx = moveDiv.offsetLeft; this.dy = moveDiv.offsetTop; &#125;, preHandler:function(e)&#123; e.preventDefault(); &#125;, move()&#123; console.log('move'); if(this.flags)&#123; var touch ; if(event.touches)&#123; touch = event.touches[0]; &#125;else &#123; touch = event; &#125; this.nx = touch.clientX - this.position.x; this.ny = touch.clientY - this.position.y; this.xPum = this.dx+this.nx; this.yPum = this.dy+this.ny; moveDiv.style.left = this.xPum+"px"; moveDiv.style.top = this.yPum +"px"; //阻止页面的滑动默认事件 document.addEventListener("touchmove",this.preHandler,false); &#125; &#125;, end()&#123; console.log('end'); //alert(e3); this.flags = false; document.removeEventListener('touchmove', this.preHandler, false); &#125;, &#125;, components: &#123; AppHeader, AppPerson, AppContent, AppProgress, AppNav // AppMask &#125;&#125;;&lt;/script&gt;&lt;style scoped lang="less"&gt;.detail &#123; position: relative; min-height:100%;&#125;.home&#123; position:fixed; right:.2rem; bottom:15%; line-height:1rem; width:.98rem; height:.98rem; img&#123; width:.98rem; height:.98rem; &#125;&#125;&lt;/style&gt; 相关知识点touchstart当在屏幕上按下手指时触发touchmove 当在屏幕上移动手指时触发 touchend 当在屏幕上抬起手指时触发mousedown mousemove mouseup对应的是PC端的事件 touchcancel 当一些更高级别的事件发生的时候（如电话接入或者弹出信息）会取消当前的touch操作，即触发touchcancel。一般 会在touchcancel时暂停游戏、存档等操作。 效果图（非对应的界面由于环境问题） 步骤详解HTML12345&lt;div class="detail"&gt; &lt;div class="home" id="moveDiv" @click="gohome" @touchstart="down" @touchmove="move" @touchend="end"&gt; &lt;img src="../../../../Img/img/home.png" alt=""&gt; &lt;/div&gt;&lt;/div&gt; JS123456789101112131415161718192021222324252627282930313233343536373839404142434445down()&#123; console.log('down'); this.flags = true; var touch ; if(event.touches)&#123; touch = event.touches[0]; &#125;else &#123; touch = event; &#125; this.position.x = touch.clientX; this.position.y = touch.clientY; this.dx = moveDiv.offsetLeft; this.dy = moveDiv.offsetTop;&#125;,preHandler:function(e)&#123; e.preventDefault();&#125;,move()&#123; console.log('move'); if(this.flags)&#123; var touch ; if(event.touches)&#123; touch = event.touches[0]; &#125;else &#123; touch = event; &#125; this.nx = touch.clientX - this.position.x; this.ny = touch.clientY - this.position.y; this.xPum = this.dx+this.nx; this.yPum = this.dy+this.ny; moveDiv.style.left = this.xPum+"px"; moveDiv.style.top = this.yPum +"px"; //阻止页面的滑动默认事件 document.addEventListener("touchmove",this.preHandler,false); &#125;&#125;, end()&#123; console.log('end'); //alert(e3); this.flags = false; document.removeEventListener('touchmove', this.preHandler, false);&#125;, CSS123456789101112131415.detail &#123; position: relative; min-height:100%;&#125;.home&#123; position:fixed; right:.2rem; bottom:15%; line-height:1rem; width:.98rem; height:.98rem; img&#123; width:.98rem; height:.98rem; &#125;]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>Mobileterminal</tag>
        <tag>Drag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端键盘弹起，底部按钮顶上去另类解决办法(Vue)]]></title>
    <url>%2F2018%2F07%2F17%2FVue%E9%94%AE%E7%9B%98%E5%BC%B9%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[当我们写一个页面有键盘弹起且底部按钮fixed时你会发现点击输入框是底部按钮会弹起，网上很多方法但是只适用于对应的场景,今天我们来学习一种Vue 页面的键盘弹起。 解决办法：换个思路，检测浏览器的resize事件，当高度过小时就可以判定为出现这种情况，这时把定位改成ab或者直接隐藏掉之类的。 方法一1&lt;mt-button v-show="isOriginHei" class="add-client" type="default" size="large" @click.native="submitClientInfo"&gt;&lt;icon-svg iconClass="baocun" class="icon-xinzeng"&gt;&lt;/icon-svg&gt;提交&lt;/mt-button&gt; 第一步： 先在 data 中去 定义 一个记录高度是 属性1234data: &#123; screenHeight: document.body.clientHeight// 这里是给到了一个默认值 （这个很重要）， originHeight: document.body.clientHeight//默认高度在watch里拿来做比较&#125; 第二步： 我们需要 讲 reisze 事件在 vue mounted 的时候 去挂载一下它的方法123456789mounted () &#123; const that = this window.onresize = () =&gt; &#123; return (() =&gt; &#123; window.screenHeight= document.body.clientHeight that.screenHeight= window.screenHeight &#125;)() &#125; &#125; 第三步： watch 去监听这个 属性值的变化，如果发生变化则讲这个val 传递给 this.screenHeight12345watch: &#123; screenHeight(val) &#123; this.screenHeight= val &#125; &#125; watch监控比较，判断按钮是否该显示出来123456789watch: &#123; screenHeight (val) &#123; if(this.originHeight != val) &#123; this.isOriginHei = false; &#125;else&#123; this.isOriginHei = true; &#125; &#125; &#125; 方法二步骤一：定义一个指令 foot123456789101112131415161718192021222324252627282930313233343536373839404142434445let listenAction;let originalHeight;let currHeight;export default new Object().install = (Vue, options = &#123;&#125;) =&gt; &#123; Vue.directive('foot', &#123; insert(el, binding) &#123; const elStyle = el.style; let active = false; originalHeight = document.body.clientHeight; const reset = () =&gt; &#123; if(!active) &#123; return ; &#125; elStyle.display = 'flex'; active = false; &#125; const hang = () =&gt; &#123; if(active) &#123; return ; &#125; elStyle.display = 'none' active = true; &#125; const getCurrHeight = () =&gt; &#123; let getHeight = document.body.clientHeight; return getHeight; &#125; const check = () =&gt; &#123; currHeight = getCurrHeight(); if(currHeight != originalHeight) &#123; hang(); &#125;else &#123; reset(); &#125; &#125; listenAction = () =&gt; &#123; check() &#125; window.addEventListener('resize', listenAction); &#125;, unbind() &#123; window.removeEventListener('resize',listenAction); &#125; &#125;)&#125; 步骤二：组件引用12import Foot from 'libs/foot'Vue.use(Foot) 步骤三：指令使用1234&lt;m-flex class="pay-group" v-foot&gt; &lt;m-flex-item class="should-pay"&gt;应付金额：&lt;span&gt;￥99&lt;/span&gt;&lt;/m-flex-item&gt; &lt;m-button @click="goPay" class="pay-btn"&gt;去支付&lt;/m-button&gt;&lt;/m-flex&gt;]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>Mobileterminal</tag>
        <tag>resize</tag>
        <tag>absolute</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始小程序]]></title>
    <url>%2F2018%2F07%2F13%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[随着技术的发展着2年微信小程序犹如一匹黑马迅速崛起，新的技术出现，我们为了不与时代脱轨学习小程序很有必要！ 开始学习准备工作 IDE搭建 知识准备 从零开始 app.js app.json app.wxml app.wxss Hello World 创建程序实例 美化ActionBar 美化页面 配置首页 超级Hello World 事件绑定函数 更新界面数据 准备工作IDE搭建就不多说了，没有内测码去下载个破解版吧，我用了一下，学习完全够了！IDE破解版+安装教程 知识准备JavaScrip还是要看看的，推荐教程 廖雪峰大神的博客 HTML+CSS 大概知道是干啥的就行 从零开始微信小程序中就四种类型的文件 js ———- JavaScrip文件 json ——– 项目配置文件，负责窗口颜色等等 wxml ——- 类似HTML文件 wxss ——- 类似CSS文件 在根目录下用app来命名的这四中类型的文件，就是程序入口文件 app.json 必须要有这个文件，如果没有这个文件，IDE会报错，因为微信框架把这个作为配置文件入口，你只需创建这个文件，里面写个大括号就行以后我们会在这里对整个小程序的全局配置。记录了页面组成，配置小程序的窗口 背景色，配置导航条样式，配置默认标题。 app.js 必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。 app.wxss 这个文件不是必须的。因为它只是个全局CSS样式文件 app.wxml 这个也不是必须的，而且这个并不是指主界面哦~因为小程序的主页面是靠在JSON文件中配置来决定的 有了这两个文件你运行程序，IDE就不会报错了，也意味着这是最简单的微信小程序 Hello World创建程序实例app.js文件管理整个程序的生命周期，所以在里面添加如下代码：（输入App IDE会有提示） 1234567891011App(&#123; onLaunch: function () &#123; console.log('App Launch') &#125;, onShow: function () &#123; console.log('App Show') &#125;, onHide: function () &#123; console.log('App Hide') &#125;&#125;) 具体API解释如下: 美化ActionBarjson文件负责配置ActionBar颜色，我们只需要在里面添加如下代码即可，下图有参数说明！ 1234567&#123; "window":&#123; "navigationBarBackgroundColor": "#BBDEF8", "navigationBarTitleText": "Demo", "navigationBarTextStyle":"white" &#125;&#125; 现在看ActionBar是不是像那么回事了！好接下来我们继续写我们第一个界面 美化页面美化页面我没用到了wxml和wxssw文件为了程序代码结构简洁我们需要在根目录下创建一个新文件夹 名字随意， 我们这里叫pages然后在pages文件夹里面再创建新文件夹 名字随意, 这里我没叫index然后我们创建index.wxml文件然后在里面写入以下代码： 123&lt;view&gt; &lt;text class=&quot;window&quot;&gt;Hello&lt;/text&gt;&lt;/view&gt; 然后创建index.wxss文件然后在里面写下以下代码 123.window&#123; color:#4995fa;&#125; 然后我们创建 index.js在文件中输入如下代码（输入Page IDE会有提示） 1234567891011121314151617181920Page(&#123; data:&#123; // text:"这是一个页面" &#125;, onLoad:function(options)&#123; // 页面初始化 options为页面跳转所带来的参数 &#125;, onReady:function()&#123; // 页面渲染完成 &#125;, onShow:function()&#123; // 页面显示 &#125;, onHide:function()&#123; // 页面隐藏 &#125;, onUnload:function()&#123; // 页面关闭 &#125;&#125;) 函数解释如下： 配置首页Json文件负责配置页面路径所以我们在里面加入如下代码 其中index的含义 其实就是指index.js文件这里需要说明一点 pages 里面的路径其实是指向js文件的 如果一个目录下没有该名称的js文件是会报错的！1"pages":[ "pages/index/index"], 完成了！我们来运行程序！ 超级Hello World为了学习事件绑定，以及如何将数据在页面上更新我们来做个超级Hello World，就是我点击文字，能让它变色！ 绑定事件我们打开index.wxml 将里面代码改成这样1&lt;view&gt; &lt;text catchtap="click" class="window"&gt;Hello&lt;/text&gt;&lt;/view&gt; 其实也就是加了：1catchtap="click"//bindtap='click' 这两个属性是什么意思呢 别着急 我会一一解释 上图展示了事件的一些的属性名称，这里需要注意红框标注起来的内容，区分出冒泡事件和非冒泡事件，其实冒泡事件就是需要往上面一层容器传递这个事件 看了这图 我们再来看 catchtap=”click” 的含义catch 代表非冒泡事件tap 代表点击事件所以连在一起就是非冒泡点击事件那后面那个click是啥click 其实只是个变量名字我们在index.js需要用这个名字绑定接收事件的函数我们打开index.js然后添加如下函数1click:function()&#123; console.log("点击了文字"); &#125; ,添加完后代码长这样 红框中就是 添加的这个代码 所以其实点击事件的回调函数 就是 catchtap=”click” 中的 click 后面加上 :function() 构成的现在我们来运行程序试试 然后点击文字 看是不是调用了click:function 并打印 点击了文字 好接下来我们写点击一下变色的逻辑那如何让一个文字变色呢，当然是css所以我们需要再index.wxss 中添加一个样式 12345.window-red&#123; color:#D23933;&#125;.window&#123;color:#49bb16;&#125;.window-red&#123;color:#D23933;&#125; 然后我们进入index.js文件你会发现代码里面有个 data:{} 它不是page生命周期函数其实他是个变量的数组，这个里面申请的变量都可以在 wxml中使用123data:&#123; color:"window"&#125; color的值就是index.wxss中的样式名称然后进入index.wxml中,将class中的值改成 123&lt;view&gt; &lt;text catchtap='click' class="&#123;&#123;color&#125;&#125;"&gt;Hello&lt;/text&gt;&lt;/view&gt; 其实意思就是 将js文件中变量 color的值在这里使用也就是值等于 window然后我们再回到index.js文件在最上面申请一个变量控制点击然后在click:function() 函数中添加如下代码:12345678910click:function()&#123; console.log("点击了文字"); if(flag)&#123; color = "window-red"; flag = false; &#125; else&#123; color = "window"; flag = true; &#125; this.setData(&#123; color &#125;);&#125;, 完后的代码如图: 其实就是在点击是后 更换color变量的值 而更换的这个值其实就是样式的名称 更新界面数据这里有个问题 我们更换完值 但是在wxml中不会立即生效所以我们需要调用this.setData()方法将值同步给wxml 让它立即生效 好了我们运行程序 点击Hello 看看是不是点一下 变一下颜色！ 最后再补充一点 index目录下也是可以配置 json文件的也就是每个页面都可以配置自己独特的actionbar颜色等等这里的配置会覆盖 app.json文件的配置]]></content>
      <tags>
        <tag>Mini-apps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Echarts简单应用]]></title>
    <url>%2F2018%2F07%2F12%2FEcharts%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[敬请期待！]]></content>
      <tags>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJs]]></title>
    <url>%2F2018%2F07%2F12%2FNodeJs%2F</url>
    <content type="text"><![CDATA[尽请期待！]]></content>
      <tags>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2018%2F07%2F12%2FAjax%2F</url>
    <content type="text"><![CDATA[敬请期待！]]></content>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识PHP]]></title>
    <url>%2F2018%2F07%2F12%2F%E5%88%9D%E8%AF%86PHP%2F</url>
    <content type="text"><![CDATA[PHP（外文名:PHP: Hypertext Preprocessor）：超文本预处理器。是一种通用开源脚本语言。语法吸收了C语言、Java和Perl的特点，利于学习，使用广泛，主要适用于Web开发领域。PHP 独特的语法混合了C、Java、Perl以及PHP自创的语法。它可以比CGI或者Perl更快速地执行动态网页用PHP做出的动态页面与其他的编程语言相比，PHP是将程序嵌入到HTML（标准通用标记语言下的一个应用）文档中去执行，执行效率比完全生成HTML标记的CGI要高许多；PHP还可以执行编译后代码，编译可以达到加密和优化代码运行，使代码运行更快。以前是没有前端这个职位的，随着计算机语言的发展Ajax的出现，有了前后端分离这一概念。]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx快速开端口]]></title>
    <url>%2F2018%2F07%2F12%2FNginx%2F</url>
    <content type="text"><![CDATA[对于一个前端来说，运行一些代码有些特殊情况需要开设端口。起初我使用静态服务器用sumlime,后面陆续使用wampserver,xampp;但是有一次换电脑了，需要重新下载，糟糕的的是突然下载不了，项目于是停止不前；庆幸的是以为Java同事告诉我用Nginx开设端口。我在这里把我这个方法分享给大家！ 第一步下载Nginx下载地址：http://nginx.org/ 第二步配置config进入conf/nignx.conf文件具体配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136 #user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events &#123; worker_connections 1024; &#125; http &#123; include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; #端口 server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root F:\GitMap1\echarts3-chinese-map-drill-down; #真实路径 index index.html index.htm; #可识别的目标文件 &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; server &#123; listen 8000; #端口 server_name localhost; location / &#123; root F:\GitMap1\echarts3-chinese-map-drill-down; #真实路径 index index.html index.htm; &#125; &#125; server &#123; listen 8080; server_name localhost; location / &#123; root F:\NewRequest\jingqingan_ganzhou; index index.html index.htm; &#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125;]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简易Python]]></title>
    <url>%2F2018%2F07%2F12%2F%E7%AE%80%E6%98%93Python%2F</url>
    <content type="text"><![CDATA[Python是由吉多·范罗苏姆(Guido Van Rossum)在90年代早期设计。它是如今最常用的编程 语言之一。它的语法简洁且优美，几乎就是可执行的伪代码。 注意：这篇教程是用Python3写的。 下面一起来学习吧！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553&#123; # 用井字符开头的是单行注释 """ 多行字符串用三个引号 包裹，也常被用来做多 行注释 """ #################################################### ## 1. 原始数据类型和运算符 #################################################### # 整数 3 # =&gt; 3 # 算术运算没有什么出乎意料的 1 + 1 # =&gt; 2 8 - 1 # =&gt; 7 10 * 2 # =&gt; 20 # 但是除法例外，会自动转换成浮点数 35 / 5 # =&gt; 7.0 5 / 3 # =&gt; 1.6666666666666667 # 整数除法的结果都是向下取整 5 // 3 # =&gt; 1 5.0 // 3.0 # =&gt; 1.0 # 浮点数也可以 -5 // 3 # =&gt; -2 -5.0 // 3.0 # =&gt; -2.0 # 浮点数的运算结果也是浮点数 3 * 2.0 # =&gt; 6.0 # 模除 7 % 3 # =&gt; 1 # x的y次方 2**4 # =&gt; 16 # 用括号决定优先级 (1 + 3) * 2 # =&gt; 8 # 布尔值 True False # 用not取非 not True # =&gt; False not False # =&gt; True # 逻辑运算符，注意and和or都是小写 True and False #=&gt; False False or True #=&gt; True # 整数也可以当作布尔值 0 and 2 #=&gt; 0 -5 or 0 #=&gt; -5 0 == False #=&gt; True 2 == True #=&gt; False 1 == True #=&gt; True # 用==判断相等 1 == 1 # =&gt; True 2 == 1 # =&gt; False # 用!=判断不等 1 != 1 # =&gt; False 2 != 1 # =&gt; True # 比较大小 1 &lt; 10 # =&gt; True 1 &gt; 10 # =&gt; False 2 &lt;= 2 # =&gt; True 2 &gt;= 2 # =&gt; True # 大小比较可以连起来！ 1 &lt; 2 &lt; 3 # =&gt; True 2 &lt; 3 &lt; 2 # =&gt; False # 字符串用单引双引都可以 "这是个字符串" '这也是个字符串' # 用加号连接字符串 "Hello " + "world!" # =&gt; "Hello world!" # 字符串可以被当作字符列表 "This is a string"[0] # =&gt; 'T' # 用.format来格式化字符串 "&#123;&#125; can be &#123;&#125;".format("strings", "interpolated") # 可以重复参数以节省时间 "&#123;0&#125; be nimble, &#123;0&#125; be quick, &#123;0&#125; jump over the &#123;1&#125;".format("Jack", "candle stick") #=&gt; "Jack be nimble, Jack be quick, Jack jump over the candle stick" # 如果不想数参数，可以用关键字 "&#123;name&#125; wants to eat &#123;food&#125;".format(name="Bob", food="lasagna") #=&gt; "Bob wants to eat lasagna" # 如果你的Python3程序也要在Python2.5以下环境运行，也可以用老式的格式化语法 "%s can be %s the %s way" % ("strings", "interpolated", "old") # None是一个对象 None # =&gt; None # 当与None进行比较时不要用 ==，要用is。is是用来比较两个变量是否指向同一个对象。 "etc" is None # =&gt; False None is None # =&gt; True # None，0，空字符串，空列表，空字典都算是False # 所有其他值都是True bool(0) # =&gt; False bool("") # =&gt; False bool([]) #=&gt; False bool(&#123;&#125;) #=&gt; False #################################################### ## 2. 变量和集合 #################################################### # print是内置的打印函数 print("I'm Python. Nice to meet you!") # 在给变量赋值前不用提前声明 # 传统的变量命名是小写，用下划线分隔单词 some_var = 5 some_var # =&gt; 5 # 访问未赋值的变量会抛出异常 # 参考流程控制一段来学习异常处理 some_unknown_var # 抛出NameError # 用列表(list)储存序列 li = [] # 创建列表时也可以同时赋给元素 other_li = [4, 5, 6] # 用append在列表最后追加元素 li.append(1) # li现在是[1] li.append(2) # li现在是[1, 2] li.append(4) # li现在是[1, 2, 4] li.append(3) # li现在是[1, 2, 4, 3] # 用pop从列表尾部删除 li.pop() # =&gt; 3 且li现在是[1, 2, 4] # 把3再放回去 li.append(3) # li变回[1, 2, 4, 3] # 列表存取跟数组一样 li[0] # =&gt; 1 # 取出最后一个元素 li[-1] # =&gt; 3 # 越界存取会造成IndexError li[4] # 抛出IndexError # 列表有切割语法 li[1:3] # =&gt; [2, 4] # 取尾 li[2:] # =&gt; [4, 3] # 取头 li[:3] # =&gt; [1, 2, 4] # 隔一个取一个 li[::2] # =&gt;[1, 4] # 倒排列表 li[::-1] # =&gt; [3, 4, 2, 1] # 可以用三个参数的任何组合来构建切割 # li[始:终:步伐] # 用del删除任何一个元素 del li[2] # li is now [1, 2, 3] # 列表可以相加 # 注意：li和other_li的值都不变 li + other_li # =&gt; [1, 2, 3, 4, 5, 6] # 用extend拼接列表 li.extend(other_li) # li现在是[1, 2, 3, 4, 5, 6] # 用in测试列表是否包含值 1 in li # =&gt; True # 用len取列表长度 len(li) # =&gt; 6 # 元组是不可改变的序列 tup = (1, 2, 3) tup[0] # =&gt; 1 tup[0] = 3 # 抛出TypeError # 列表允许的操作元组大都可以 len(tup) # =&gt; 3 tup + (4, 5, 6) # =&gt; (1, 2, 3, 4, 5, 6) tup[:2] # =&gt; (1, 2) 2 in tup # =&gt; True # 可以把元组合列表解包，赋值给变量 a, b, c = (1, 2, 3) # 现在a是1，b是2，c是3 # 元组周围的括号是可以省略的 d, e, f = 4, 5, 6 # 交换两个变量的值就这么简单 e, d = d, e # 现在d是5，e是4 # 用字典表达映射关系 empty_dict = &#123;&#125; # 初始化的字典 filled_dict = &#123;"one": 1, "two": 2, "three": 3&#125; # 用[]取值 filled_dict["one"] # =&gt; 1 # 用keys获得所有的键。因为keys返回一个可迭代对象，所以在这里把结果包在list里。我们下面会详细介绍可迭代。 # 注意：字典键的顺序是不定的，你得到的结果可能和以下不同。 list(filled_dict.keys()) # =&gt; ["three", "two", "one"] # 用values获得所有的值。跟keys一样，要用list包起来，顺序也可能不同。 list(filled_dict.values()) # =&gt; [3, 2, 1] # 用in测试一个字典是否包含一个键 "one" in filled_dict # =&gt; True 1 in filled_dict # =&gt; False # 访问不存在的键会导致KeyError filled_dict["four"] # KeyError # 用get来避免KeyError filled_dict.get("one") # =&gt; 1 filled_dict.get("four") # =&gt; None # 当键不存在的时候get方法可以返回默认值 filled_dict.get("one", 4) # =&gt; 1 filled_dict.get("four", 4) # =&gt; 4 # setdefault方法只有当键不存在的时候插入新值 filled_dict.setdefault("five", 5) # filled_dict["five"]设为5 filled_dict.setdefault("five", 6) # filled_dict["five"]还是5 # 字典赋值 filled_dict.update(&#123;"four":4&#125;) #=&gt; &#123;"one": 1, "two": 2, "three": 3, "four": 4&#125; filled_dict["four"] = 4 # 另一种赋值方法 # 用del删除 del filled_dict["one"] # 从filled_dict中把one删除 # 用set表达集合 empty_set = set() # 初始化一个集合，语法跟字典相似。 some_set = &#123;1, 1, 2, 2, 3, 4&#125; # some_set现在是&#123;1, 2, 3, 4&#125; # 可以把集合赋值于变量 filled_set = some_set # 为集合添加元素 filled_set_add(5) # filled_set现在是&#123;1, 2, 3, 4, 5&#125; # &amp; 取交集 other_set = &#123;3, 4, 5, 6&#125; filled_set &amp; other_set # =&gt; &#123;3, 4, 5&#125; # | 取并集 filled_set | other_set # =&gt; &#123;1, 2, 3, 4, 5, 6&#125; # - 取补集 &#123;1, 2, 3, 4&#125; - &#123;2, 3, 5&#125; # =&gt; &#123;1, 4&#125; # in 测试集合是否包含元素 2 in filled_set # =&gt; True 10 in filled_set # =&gt; False #################################################### ## 3. 流程控制和迭代器 #################################################### # 先随便定义一个变量 some_var = 5 # 这是一个if语句。注意缩进在Python里是有意义的 # 打印出"some_var比10小" if some_var &gt; 10: print("some_var比10大") elif some_var &lt; 10: # elif句是可选的 print("some_var比10小") else: # else也是可选的 print("some_var就是10") """ 用for循环语句遍历列表 打印: dog is a mammal cat is a mammal mouse is a mammal """ for animal in ["dog", "cat", "moouse"]: print("&#123;&#125; is a animal".format(animal)) """ "range(number)"返回数字列表从0到给的数字 打印: 0 1 2 3 """ for i in range(4): print(i) """ while循环直到条件不满足 打印: 0 1 2 3 """ x = 0 while x &lt; 4: print(x) x += 1 # x = x + 1 的简写 # 用try/except块处理异常状况 try: # 用raise抛弃异常 raise IndexError("This is an index error") except IndexError as e: pass # pass是无操作，但是应该在这里处理错误 except (TypeError, NameError): pass # 可以同时处理不同类的错误 else: # else语句是可选的，必须在所有的except之后 print("All good!") # 只有当try运行完没有错误的时候这句才会运行 # Python提供一个叫做可迭代(iterable)的基本抽象。一个可迭代对象是可以被当作序列 # 的对象。比如说上面range返回的对象就是可迭代的。 filled_dict = &#123;"one": 1, "two": 2, "three": 3&#125; our_iterable = filled_dic.keys() print(our_iterable) # =&gt; range(1,10) 是一个实现可迭代接口的对象 # 可迭代对象可以遍历 for i in our_iterable: print(i) # 打印 one, two, three # 但是不可以随机访问 our_iterable[1] # 抛出TypeError # 可迭代对象知道怎么生成迭代器 our_iterable = iter(our_iterable) # 迭代器是一个可以记住遍历的位置的对象 # 用__next__可以取得下一个元素 our_iterable.__next__() #=&gt; "one" # 再一次调用__next__时会记得位置 our_iterator.__next__() #=&gt; "two" our_iterator.__next__() #=&gt; "three" # 当迭代器所有元素都取出后，会抛出StopIteration our_iterator.__next__() # 抛出StopIteration # 可以用list一次取出迭代器所有元素 list(filled_dict.keys()) #=&gt; Returns ["one", "two", "three"] #################################################### ## 4. 函数 #################################################### # 用def定义新函数 def add(x, y): print("x is &#123;&#125; and y is &#123;&#125;".formatm(x, y)) return x + y 用return语句返回 # 调用函数 add(5, 6) # =&gt; 打印出"x is 5 and y is 6"并且返回11 # 也可以用关键字参数来调用函数 add(y=6, x=5) # 关键字参数可以用任何顺序 #我们可以定义一个可变参数函数 def varargs(*args): return args varargs(1, 2, 3) # =&gt; (1, 2, 3) # 我们也可以定义一个关键字可变参数函数 def keyword_args(**kwargs): return kwargs # 看看结果是什么 keyword_args(big="foot", loch="ness") # =&gt; &#123;"big": "foot", "loch": "ness"&#125; # 这两种可变参数可以混着用 def all_the args(*args, **kwargs): print(args) print(kwargs) """ all_the_args(1, 2, a=3, b=4) prints: (1, 2) &#123;"a": 3, "b": 4&#125; """ # 调用可变参数函数时可以做跟上面相反的，用*展开序列，用**展开字典。 args = (1, 2, 3, 4) kwargs = &#123;"a": 3, "b": 4&#125; all_the_args(*args) # 相当于 foo(1, 2, 3, 4) all_the_args(**kwargs) # 相当于 foo(a=3, b=4) all_the_args(*args, **kwargs) # 相当于 foo(1, 2, 3, 4, a=3, b=4) # 函数作用域 x = 5 def setX(num): # 局部作用域的x和全局作用域的x是不同的 x = num # =&gt; 43 print (x) # =&gt; 43 def setGlobalX(num): global x print (x) # =&gt; 5 x = num #现在全局作用域的x被赋值 print (x) # =&gt; 6 setX(43) setGlobalX(6) # 函数在Python是一等公民 def create_adder(x): def adder(y): return x + y return adder add_10 = create_adder(10) add_10(3) # =&gt; 13 # 也有匿名函数 (lambda x: x &gt; 2)(3) # =&gt; True # 内置的高阶函数 map(add_10, [1, 2, 3]) # =&gt; [11, 12, 13] filter(lambda x: x &gt; 5, [3, 4, 5, 6, 7]) # =&gt; [6, 7] #用列表推导式可以简化映射和过滤。列表推导式的返回值是另一个列表。 [add_10(i) for i in [1, 2, 3]] # =&gt; [11, 12, 13] [x for x in [3, 4, 5, 6, 7] if x &gt; 5] # =&gt; [6, 7] #################################################### ## 5. 类 #################################################### # 定义一个继承object的类 class Human(object): # 类属性，被所有此类的实例共用。 species = "H. sapiens" # 构造方法，当实例被初始化时调用。注意名字前后的双下划线，这是表名这个属 # 性或方法对Python有特殊意义，但是允许用户自定义。自己取名时不应该用这种格式 def __init__(self, name): # Assign the argument to the instance's name attribute self.name = name # 实例方法，第一个参数总是self，就是这个实例对象 def say(self, msg): return "&#123;name&#125;: &#123;message&#125;".format(name=self.name, message=msg) # 类方法，被所有此类的实例共用。第一个参数是这个类对象。 @classmethod def get_species(cls): return cls.species # 静态方法。调用时没有实例或类的绑定。 @staticmethod def grunt(): return "*grunt*" # 构造一个实例 i = Human(name="Ian") print(i.say("hi")) # 打印出 "Ian: hi" j = Human("Joel") print(j.say("hello")) # 印出 "Joel: hello" # 调用一个类方法 i.get_species() # =&gt; "H. sapiens" # 改一个共用的类属性 Human.species = "H. neanderthalensis" i.get_species() # =&gt; "H. neanderthalensis" j.get_species() # =&gt; "H. neanderthalensis" # 调用静态方法 Human.grunt() # =&gt; "*grunt*" #################################################### ## 6. 模块 #################################################### # 用import导入模块 import math print(math.sqrt(16)) # =&gt; 4.0 # 也可以从模块中导入个别值 from math import ceil,floor print(ceil(3.7)) # =&gt; 4.0 print(floor(3.7)) # =&gt; 3.0 # 可以导入一个模块中所有值 # 警告：不建议这么做 from math import * # 如此缩写模块名字 import math as m math.sqrt(16) == m.sqrt(16) # =&gt; True # Python模块其实就是普通的Python文件。 # 你可以自己写，然后导入，模块的名字就是文件的名字。 # 你可以这样列出一个模块里所有的值 import math dir(math) #################################################### ## 7. 高级用法 #################################################### # 用生成器(generators)方便的写惰性计算 def double_numbers(iterable): for i in iterable: yield i + i # 生成器只有在需要时才计算下一个值。它们每一次循环只生成一个值，而不是把所有的 # 值全部计算好。这意味着double_numbers不会生成大于15的数字。 # # range的返回值也是一个生成器，不然一个1到900000000的列表会花很多时间和内存。 # # 如果你想用一个Python的关键字当作变量，可以加一个下划线来区分。 range_ = range(1, 900000000) # 当找到一个 &gt;= 30 的结果就会停 for i in double_numbers(range_): print(i) if i &gt;= 30: break # 装饰器(decorators) # 这个例子中，beg装饰say # beg会先调用say。如果返回的say_please为真，beg会改变返回的字符串。 from functools import wraps def beg(target_function): @wraps(target_function) def wrapper(*args, **kwargs): msg, say_please = target_function(*args, **kwargs) if say_please: return "&#123;&#125; &#123;&#125;".format(msg, "Please! I am poor :(") return msg return wrapper @beg def say(say_please=False): msg = "Can you buy me a beer?" return msg, say_please print(say()) # Can you buy me a beer? print(say(say_please=True)) # Can you buy me a beer? Please! I am poor :(&#125;]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Linux]]></title>
    <url>%2F2018%2F07%2F12%2F%E5%88%9D%E8%AF%86Linux%2F</url>
    <content type="text"><![CDATA[初步认识Linux,我们一起来预览一下命令吧！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&#123; $ date 显示系统当前时间和日期 $ cal 显示当前月份的日历 $ df 查看磁盘剩余空间的数量 $ free 显示空闲内存的数量 $ exit 结束终端会话 &lt;!--more--&gt; $ pwd 打印出当前工作目录名 $ cd 更改目录 $ ls 列出目录内容 $ file 确定文件类型 $ less 浏览文件内容 $ cp 复制文件和目录 $ mv 移动/重命名文件和目录 $ mkdir 创建目录 $ rm 删除文件和目录 $ ln 创建硬链接和符号链接 $ type 说明怎样解释一个命令名 $ which 显示会执行哪个可执行程序 $ man 显示命令手册页 $ apropos 显示一系列适合的命令 $ info 显示命令 info $ whatis 显示一个命令的简洁描述 $ alias 创建命令别名 $ unalias 删除命令别名 $ cat 连接文件 $ sort 排序文本行 $ uniq 报道或省略重复行 $ grep 打印匹配行 $ wc 打印文件中换行符，字，和字节个数 $ head 输出文件第一部分 $ tail 输出文件最后一部分 $ echo 显示一行文本 $ clear 清空屏幕 $ history 显示历史列表内容&#125;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM]]></title>
    <url>%2F2018%2F07%2F11%2FDOM%2F</url>
    <content type="text"><![CDATA[DOM: Document Object Model（文档对象模型）,DOM 是 W3C（万维网联盟）的标准。“W3C 文档对象模型 （DOM） 是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。”W3C DOM 标准被分为 3 个不同的部分： 核心 DOM - 针对任何结构化文档的标准模型 XML DOM - 针对 XML 文档的标准模型 HTML DOM - 针对 HTML 文档的标准模型 DOM节点根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点： 整个文档是一个文档节点 每个 HTML 元素是元素节点 HTML 元素内的文本是文本节点 每个 HTML 属性是属性节点 注释是注释节点 HTML DOM 节点树（DOM树）HTML DOM 将 HTML 文档视作树结构。这种结构被称为节点树： 通过 HTML DOM，树中的所有节点均可通过 JavaScript 进行访问。所有 HTML 元素（节点）均可被修改，也可以创建或删除节点。 HTML DOM 对象 - 方法和属性获取页面元素123456* document.getElementById(&apos;list&apos;) ---- 返回DOM节点 速度最快* document.getElementsByTagName(&apos;div) ---- 返回类数组* document.getElementsByClassName(&apos;list&apos;) ---- 返回类数组 ie8 有兼容性问题* document.getElementsByName() --- 返回类数组 如：获取表单name属性* ducument.body ---- 获取body* 通过id 获取不到返回null，其他几项返回 []. DOM对象方法预览 方法 描述 getElementById() 返回带有指定 ID 的元素。 getElementsByTagName() 返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。 getElementsByClassName() 返回包含带有指定类名的所有元素的节点列表。 appendChild() 把新的子节点添加到指定节点。 removeChild() 删除子节点。 replaceChild() 替换子节点 insertBefore() 在指定的子节点前面插入新的子节点。 createAttribute() 创建属性节点。 createElement() 创建元素节点。 createTextNode() 创建文本节点。 getAttribute() 返回指定的属性值。 setAttribute() 把指定属性设置或修改为指定的值 节点的类型nodetype 节点的属性 节点类型 nodetype 元素节点 1 文本节点 3 属性节点 2 注释节点 8 文档节点 9 节点的属性 nodetype 取值：1,2,3 nodeName 取值元素的标签名 如DIV。 文本：#text nodeValue 获取节点的值 文本 属性 DOM节点的增删查改 创建元素节点 1document.createElement('div'); 创建文本节点 1document.creatTextNode('你好'); 插入节点 12345var parent=document.getElementById("div1"); //父元素 1. parent.appendChild() //往后面加2. parent.insertBefoer(new,node); //通过父级在node节点前面添加新的节点 ps:已经存在页面上的元素，如果使用appendchild,insertBefore操作则会移动这个元素 复制节点 12ele.cloneNode(boolean);ele.cloneNode(boolean,true); // true为深复制 删除节点 1parent.removeChild(ele); 判断是否存在节点 1parent.hasChildNode() //返回布尔值 ps:1.标准浏览器中：换行会解析为一个文本节点（即解析空格）。2.在ie8中会忽略上述问题 节点关系和元素关系 关系 节点关系 元素关系(存在兼容性问题 children无兼容性问题) 父级 parentNode parentElement 子级 childNode children 第一个子级 firstChild firstElementChild 最后个子级 lastChild lastElementChild 前一个兄弟 previousSibling previousElementSibling 后一个兄弟 nextSibling nextElementSibling 文本 – 文本 ele.innerHTML(含标签) 文本 ele.innerText(单纯文字) 文本 ele.outerHTML 文本 ele.outerText 属性节点注意：只有html的标准属性才能直接获取例如：id ,className,title等 设置非标准属性 1setAttribute(attr,val) 获取非标准属性 1ele.getAttribute('name'); 判断是否存在某费标准属性 1ele.hasAttribute(attr) //返回布尔值 删除属性 1ele.removeAttribute(attr) CSS:style属性ps:ele.style设置或改变的是内联样式 获取非内联样式 123getComputedStyle(ele); //计算过后getComputedStyle(ele).fontSize;getComputedStyle(ele).[font-size];//[attr] 获取伪元素样式 123getCompuyedStyle(ele,"::before").color;getCompuyedStyle(ele,"::before").fontSize;getCompuyedStyle(ele,"::before").[font-size];//兼容ie8-]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用]]></title>
    <url>%2F2018%2F07%2F05%2FHexo%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[经过一段时间的折腾终于用 Hexo + GitHub 搭建起了一个个人博客站点，第一时间边学边写，弄出了这第一篇博客，心里甚是欢喜。 Hexo是一款“快速、简洁且高效的博客框架”，支持 Markdown 的所有功能。所以，写出一篇博客必须学习 Hexo 和 Markdown 的使用规则。 配置文件命名规则和路由地址Hexo 默认以标题作为文件名称，可以通过 Hexo 的配置文件 _config.yml 中的 new_post_name 参数来改变默认的文件名称，例如： 1new_post_name: :year-:month-:day-:title.md 当创建博客时，就会以这种格式生成Markdown文件，如这篇博客的文件名就生成 2017-01-13-hexo-blog.md 这种形式。其中相关变量说明如下表： 变量 说明 :title 标题（小写，空格将会被替换为短杠） :year 创建的年份，如：2017 :month 创建的月份（有前导零），如：01 :i_month 创建的月份（无前导零），如：1 :day 创建的日期（有前导零），如：09 :i_day 创建的月份（无前导零），如：9 配置浏览器地址栏中的URL。同样在 Hexo 的配置文件 _config.yml 中, 配置 permalink 属性 ，例如： 1permalink: /blog/:year/:month/:day/:title/ 当在地址栏访问时，就会如下方式呈现出来：1http://localhost:4000/blog/2017/01/13/hexo-blog/ 特殊字符在写博客时,一定注意不要写这些字符,如果要写,就进行转义有些人可能说可以使用反斜杠 \ 来处理,我这里不建议,因为我使用的时候没有解决问题。下面是比较常见的几个:12345678910111213141516171819202122232425262728293031323334353637383940414243! &amp;#33; — 惊叹号Exclamation mark ” &amp;#34; &amp;quot; 双引号Quotation mark # &amp;#35; — 数字标志Number sign $ &amp;#36; — 美元标志Dollar sign % &amp;#37; — 百分号Percent sign &amp; &amp;#38; &amp;amp; Ampersand ‘ &amp;#39; — 单引号Apostrophe ( &amp;#40; — 小括号左边部分Left parenthesis ) &amp;#41; — 小括号右边部分Right parenthesis * &amp;#42; — 星号Asterisk + &amp;#43; — 加号Plus sign &lt; &amp;#60; &amp;lt; 小于号Less than = &amp;#61; — 等于符号Equals sign &gt; &amp;#62; &amp;gt; 大于号Greater than ? &amp;#63; — 问号Question mark @ &amp;#64; — Commercial at [ &amp;#91; --- 中括号左边部分Left square bracket \ &amp;#92; --- 反斜杠Reverse solidus (backslash) ] &amp;#93; — 中括号右边部分Right square bracket &#123; &amp;#123; — 大括号左边部分Left curly brace | &amp;#124; — 竖线Vertical bar &#125; &amp;#125; — 大括号右边部分Right curly brace 特别注意的是小括号 ( ) 大括号 { } ,如果不小心写了,你执行hexo s –debug可能报一些莫名其妙的错误! 创建博客在命令行中用如下命令创建一篇新的文章1$ hexo new [layout] &lt;title&gt; 布局（layout） 存储路径 说明 post source/_posts 默认，可以直接发布 page source 在source下新建一个文件夹 draft source/_drafts 新建文件将保持到_drafts中 可以用 publish 命令将草稿移动到 source/_posts 文件夹下1$ hexo publish [layout] &lt;title&gt; 写作经过上面上面一系列的准备工作，现在差不多就可以安心的写作了。打开 source/_posts 文件夹下刚创建的 Markdown 文件，你会发现有如下内容：12345---title: hexo-blogdate: 2017-01-13 16:07:32tags: --- 注意，这里的 title 是可以随便改的，当然了 date 也是可以改，不过没有改的必要；这里要说一下 tags 这个属性，如果需要配置多个有两种方式：1tags: [tag1, tag2, tag3] 1234tags: - tag1 - tag2 - tag3 Hexo 是支持 Markdown 的所有功能的，所以，下面去学习一下 Markdown 的语法规范 斜体和粗体写法：123*斜体文本* _斜体文本_**粗体文本** __粗体文本__***粗斜体文本*** ___粗斜体文本___ 效果：斜体文本 斜体文本粗体文本 粗体文本粗斜体文本 粗斜体文本 分级标题写法：123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 超链接写法：123456789101112行内形式：[我的博客](https://Lee981265.github.io/)参考形式：[我的博客][1]，有一个很好的平台-[简书][2].这个链接用 yahoo 作为网址变量 [Yahoo!][yahoo].[yahoo]: http://www.yahoo.com/[1]:https://Lee981265.github.io/[2]:http://www.jianshu.com/自动链接：我的博客地址&lt;https://Lee981265.github.io/&gt;作者：KevinPu链接：https://www.jianshu.com/p/56d99a3049a5來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 效果：行内形式：我的博客参考形式：[我的博客][1]，有一个很好的平台-[简书][2][1]:https://Lee981265.github.io/[2]:http://www.jianshu.com/自动链接：我的博客地址https://Lee981265.github.io/ 作者：KevinPu链接：https://www.jianshu.com/p/56d99a3049a5來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 列表无序列表：写法：123* 无序列表项1+ 无序列表项2- 无序列表项3 效果： 无序列表项1 无序列表项2 无序列表项3 有序列表写法：1231. 有序列表项12. 有序列表项23. 有序列表项3 效果 有序列表项1 有序列表项2 有序列表项3 列表嵌套12345678910111. 列出所有元素： - 无序列表元素 A 1. 元素 A 的有序子列表 - 前面加四个空格2. 列表里的多段换行： 前面必须加四个空格， 这样换行，整体的格式不会乱3. 列表里引用： &gt; 前面空一行 &gt; 仍然需要在 &gt; 前面加四个空格 列出所有元素： 无序列表元素 A 元素 A 的有序子列表 前面加四个空格 列表里的多段换行： 前面必须加四个空格， 这样换行，整体的格式不会乱 列表里引用： 前面空一行仍然需要在 &gt; 前面加四个空格 引用 普通引用 12&gt; 引用文本前使用 [大于号+空格]&gt; 折行可以不加，新起一行都要加上哦 引用里嵌套引用 123&gt; 最外层引用&gt; &gt; 多一个 &gt; 嵌套一层引用&gt; &gt; &gt; 可以嵌套很多层 引用里嵌套列表 123&gt; - 这是引用里嵌套的一个列表&gt; - 还可以有子列表&gt; * 子列表需要从 - 之后延后四个空格开始 插入图片在 Hexo 中插入图片，首先需要将图片放在 source/img/ 文件夹下，然后如下方式进行插入12345678![这是图片说明](/img/Leebolg.png)这个链接用 1 作为网址变量 [ Google] [ 1].然后在文档的结尾位变量赋值(网址) [1]: http: //www.google.com/logo.png 也可以使用 HTML 的图片语法来自定义图片的宽高大小 &lt;img src=&quot;https://lee981265.github.io/img/Leebolg.png&quot; width=&quot;240&quot; height=&quot;275&quot;&gt; 效果图如下： 换行如果另起一行，只需在当前行结尾加 2 个空格123在当前行的结尾加 2 个空格 这行就会新起一行如果是要起一个新段落，只需要空出一行即可。 分隔符如果你有写分割线的习惯，可以新起一行输入三个减号-。当前后都有段落时，请空出一行：12345前面的段落---后面的段落 小型文本Markdown语法：1&lt;small&gt;文本内容&lt;/small&gt; 预览效果：我是正常文字我是小型文字 注释用html的注释，好像只有这样？1&lt;!-- 注释 --&gt; 表格123456789101112131415161718192021| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 || 表头1|表头2|表头3|表头4|-| :- | :-: | -: ||默认左对齐|左对齐|居中对其|右对齐||默认左对齐|左对齐|居中对其|右对齐||默认左对齐|左对齐|居中对其|右对齐|| 参数 | 说明 | 默认值 || ------------- |:-------------------:|:------------------:|| host | 远程主机的地址 | || user | 使用者名称 | || root | 远程主机的根目录 | || port | 端口 | 22 || delete | 删除远程主机上的旧文件 | true || verbose | 显示调试信息 | true || ignore_errors | 忽略错误 | false | 效果： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 表头1 表头2 表头3 表头4 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 参数 说明 默认值 host 远程主机的地址 user 使用者名称 root 远程主机的根目录 port 端口 22 delete 删除远程主机上的旧文件 true verbose 显示调试信息 true ignore_errors 忽略错误 false 总结记录了一下 Hexo 写博客的环境配置，了解创建博客的过程和一些相关的变量，然后学习一下 Markdown 的基本语法规范，下次有时间在将 Markdown 更深入的使用方法记录一下。]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git进阶]]></title>
    <url>%2F2018%2F07%2F05%2FGit%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 与 SVN 区别 GIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。如果你是一个具有使用SVN背景的人，你需要做一定的思想转换，来适应GIT提供的一些概念和特征。 Git 与 SVN 区别点： 1、GIT是分布式的，SVN不是：这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。 2、GIT把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。 3、GIT分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。 4、GIT没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。 5、GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 Git命令我们先来预览一下Git命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&#123; mkdir： XX (创建一个空目录 XX指目录名) pwd： 显示当前目录的路径。 git init 把当前的目录变成可以管理的git仓库，生成隐藏.git文件。 git add XX 把xx文件添加到暂存区去。 git reset --mixed 把上次add文件撤销但修改保留。 git commit –m “XX” 提交文件 –m 后面的是注释。 git status 查看仓库状态 git diff XX 查看XX文件修改了那些内容 git log 查看历史记录 git reset –-hard HEAD^ 或者 git reset –-hard HEAD~ 回退到上一个版本 (如果想回退到100个版本，使用git reset –-hard HEAD~100 ) cat XX 查看XX文件内容 git reflog 查看历史记录的版本号id git checkout — XX 把XX文件在工作区的修改全部撤销。 git rm XX 删除XX文件 git rm * 删除所有文件 git remote add origin https://github.com/tugenhua0707/testgit 关联一个远程库 git push –u(第一次要用-u 以后不需要) origin master 把当前master分支推送到远程库 git clone https://github.com/tugenhua0707/testgit 从远程库中克隆 git checkout –b dev 创建dev分支 并切换到dev分支上 git branch 查看当前所有的分支 git checkout master 切换回master分支 git merge dev 在当前的分支上合并dev分支 git branch –d dev 删除dev分支 git branch name 创建分支 git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作 git stash list 查看所有被隐藏的文件列表 git stash apply 恢复被隐藏的文件，但是内容不删除 git stash drop 删除文件 git stash pop 恢复文件的同时 也删除文件 git remote 查看远程库的信息 git remote –v 查看远程库的详细信息 git push origin master Git会把master分支推送到远程库对应的远程分支上&#125; Git深度理解123456789101112131415161718&#123; 1.git进入vim界面 输入Ctrl+Z 即可退出 ////////Esc Shift+: 2.查看git所有已配置项 $ git config --list 3.Git撤销commit的操作命令 git reset --hard HEAD^ git reset --hard commitID git reset --hard HEAD@&#123;n&#125; 4.git 撤销初始化 删除 .git 文件即可 或者执行命令 rm -rf .git 5.git add . 出现以下报错 ---------- warning: LF will be replaced by CRLF in XXXXXXXXXXXXXX. ---解决方案：执行命令git config core.autocrlf false 6. 查看git本机 用户名： $ git config --global user.name 邮箱： $ git config --global user.email 更改本机配置 用户名： $ git config --global user.name &quot;Lee&quot; 邮箱： $ git config --global user.email &quot;Jack2244057555@gmail.com&quot;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174&#123; 一.Git命令解析 1、git基本命令 1）git add 将想要快照的内容写入缓存区 2）git status -s &quot;AM&quot; 状态的意思是，这个文件在我们将它添加到缓存之后又有改动 3）git commit -m &apos;第一次版本提交&apos; -m选项添加备注信息 4）git clone url 使用 git clone 拷贝一个 Git 仓库到本地 5）git diff 查看执行 git status 的结果的详细信息 尚未缓存的改动：git diff 查看已缓存的改动： git diff --cached 查看已缓存的与未缓存的所有改动：git diff HEAD 显示摘要而非整个 diff：git diff --stat 6）git commit -a 跳过git add 提交缓存的流程 7）git reset HEAD 用于取消已缓存的内容 8）git rm file git rm 会将条目从缓存区中移除。这与 git reset HEAD 将条目取消缓存是有区别的。 &quot;取消缓存&quot;的意思就是将缓存区恢复为我们做出修改之前的样子。 默认情况下，git rm file 会将文件从缓存区和你的硬盘中（工作目录）删除。 9）git mv 重命名磁盘上的文件 如 git mv README README.md 10）git push -u origin master 提交代码 2、git 分支管理 1）创建分支命令 git branch (branchname) 列出分支 git branch 2）切换分支命令 git checkout (branchname) 3）合并分支 git merge (branchname) 4）创建新分支并立即切换到该分支下 git checkout -b (branchname) 5）删除分支命令 git branch -d (branchname) ps:状态 uu 表示冲突未解决 可以用 git add 要告诉 Git 文件冲突已经解决 3、查看日志版本 git log 命令列出历史提交记录 git log --oneline 查看历史记录的简洁的版本 git log --oneline --graph 查看历史中什么时候出现了分支、合并 4、标签 为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 1.0.0 的标签： git tag 1.0.0 1b2e1d63ff 1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令获取提交 ID： git log 你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性 5、提取远程仓库代码 1）git fetch 从远程仓库下载新分支与数据 2)）git pull 从远端仓库提取数据并尝试合并到当前分支 6、git分支 git-flow主要有5中分支：master、hotfix、release、develop、feature feature分支开始于develop分支，完成以后合并到develop分支。 当完成一定数量feature分支以后，从develop再开一个release分支出来，这些特性将被更行到下一个发布的版本中， 之后的feature将不会被合并到release中。 之后在release分支中，只修改bug，然后完成release分支。完成release分支会完成以下三个操作： 1、合并release分支到master； 2、给master打上版本的标签 3、release回归到develop分支。 当发现master上有bug时，开一个hotfix，完成后合并到master分支。 初次安装git配置用户名和邮箱 初次安装git需要配置用户名和邮箱，否则git会提示：please tell me who you are. 你需要运行命令来配置你的用户名和邮箱： $ git config --global user.name &quot;superGG1990&quot; $ git config --global user.email &quot;superGG1990@163.com&quot; 注意：（引号内请输入你自己设置的名字，和你自己的邮箱）此用户名和邮箱是git提交代码时用来显示你身份和联系方式的，并不是github用户名和邮箱 git使用ssh密钥 git支持https和git两种传输协议，github分享链接时会有两种协议可选： git协议链接图例 : ↓ https协议链接图例：↓ git使用https协议，每次pull, push都会提示要输入密码，使用git协议，然后使用ssh密钥，这样免去每次都输密码的麻烦 初次使用git的用户要使用git协议大概需要三个步骤： 一、生成密钥对 二、设置远程仓库（本文以github为例）上的公钥 三、把git的 remote url 修改为git协议（以上两个步骤初次设置过以后，以后使用都不需要再次设置，此步骤视以后项目的remote url而定，如果以后其他项目的协议为https则需要此步骤） 一、生成密钥对 大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先你要确认一下本机是否已经有一个公钥。 SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。进去看看： $ cd ~/.ssh $ ls authorized_keys2 id_dsa known_hosts config id_dsa.pub 看一下有没有id_rsa和id_rsa.pub(或者是id_dsa和id_dsa.pub之类成对的文件)，有 .pub 后缀的文件就是公钥，另一个文件则是密钥。 假如没有这些文件，甚至连 .ssh 目录都没有，可以用 ssh-keygen 来创建。该程序在 Linux/Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里： $ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; Creates a new ssh key using the provided email # Generating public/private rsa key pair. Enter file in which to save the key (/home/you/.ssh/id_rsa): 直接按Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码)： Enter same passphrase again: [Type passphrase again] 完了之后，大概是这样： Your public key has been saved in /home/you/.ssh/id_rsa.pub. The key fingerprint is: # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@youremail.com 到此为止，你本地的密钥对就生成了。 二、添加公钥到你的远程仓库（github） 1、查看你生成的公钥： $ cat ~/.ssh/id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0X6L1zLL4VHuvGb8aJH3ippTozmReSUzgntvk434aJ/v7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8vR3c8E7CjZN733f5AL8uEYJA+YZevY5UCvEg+umT7PHghKYaJwaCxV7sjYP7Z6V79OMCEAGDNXC26IBMdMgOluQjp6o6j2KAdtRBdCDS/QIU5THQDxJ9lBXjk1fiq9tITo/aXBvjZeD+gH/Apkh/0GbO8VQLiYYmNfqqAHHeXdltORn8N7C9lOa/UW3KM7QdXo6J0GFlBVQeTE/IGqhMS5PMln3 admin@admin-PC 2、登陆你的github帐户。点击你的头像，然后 Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key 3、然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，自己随便起个名字。 4、点击 Add key。 完成以后，验证下这个key是不是正常工作： $ ssh -T git@github.com Attempts to ssh to github 如果，看到： Hi xxx! You&apos;ve successfully authenticated, but GitHub does not # provide shell access. 恭喜你，你的设置已经成功了。 三、修改git的remote url 使用命令 git remote -v 查看你当前的 remote url $ git remote -v origin https://github.com/someaccount/someproject.git (fetch) origin https://github.com/someaccount/someproject.git (push) 如果是以上的结果那么说明此项目是使用https协议进行访问的（如果地址是git开头则表示是git协议） 你可以登陆你的github，就像本文开头的图例，你在上面可以看到你的ssh协议相应的url，类似： 复制此ssh链接，然后使用命令 git remote set-url 来调整你的url。 git remote set-url origin git@github.com:someaccount/someproject.git 然后你可以再用命令 git remote -v 查看一下，url是否已经变成了ssh地址。 然后你就可以愉快的使用git fetch, git pull , git push，再也不用输入烦人的密码了 &#125;]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前言]]></title>
    <url>%2F2018%2F07%2F03%2Fpreface%20%2F</url>
    <content type="text"><![CDATA[这是我首次使用hexojs编写博客那么我就来试一试更多内容的相关功能吧！]]></content>
      <tags>
        <tag>ABC</tag>
        <tag>CBA</tag>
      </tags>
  </entry>
</search>
